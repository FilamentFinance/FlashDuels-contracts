// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/// @title FlashDuels
/// @notice This contract allows users to create and participate in duels by betting on the options.
contract FlashDuels is UUPSUpgradeable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
    /// @notice Thrown when the bot address is invalid
    error FlashDuels__InvalidBot();
    /// @notice Total protocol fees generated by the contract

    uint256 public totalProtocolFeesGenerated;
    /// @notice Protocol fee percentage taken from the winnings (default 2%)
    uint256 public protocolFeePercentage;
    /// @notice Fee percentage given to the duel creator (default 2%)
    uint256 public creatorFeePercentage;
    /// @notice Time period for bootstrapping before a duel goes live (30 minutes by default)
    uint256 public bootstrapPeriod;
    /// @notice Fee in USDC required to create a duel
    uint256 public createDuelFee;
    /// @notice The minimum threshold for wagering, set to 50 USDC (or configurable)
    uint256 public minThreshold;
    /// @notice Nonce used to generate unique duel IDs
    uint256 private nonce;
    // address => duelId => option => userWager
    mapping(address => mapping(string => mapping(string => uint256))) public userWager;
    // duelId => option => totalWagerForOption
    mapping(string => mapping(string => uint256)) public totalWagerForOption;
    // duelId => option => duelUsersForOption
    mapping(string => mapping(string => address[])) public duelUsersForOption;
    // duelId => token => price
    mapping(string => mapping(address => int256)) public startPriceToken;
    /// @notice Tracks total fees earned by duel creators
    mapping(address => uint256) public totalCreatorFeeEarned;
    /// @notice To store multiple duel IDs for the same combination
    mapping(address => string[]) public creatorToDuelIds;
    // duelId => options
    mapping(string => string[]) public duelIdToOptions;
    // duelId => tokens
    mapping(string => address[]) public duelIdToTokens;
    /// @notice Mapping of token addresses to their price aggregators
    mapping(address => address) public priceAggregator;
    /// @notice Tracks total earnings for participants
    mapping(address => uint256) public allTimeEarnings;
    /// @notice Mapping of supported token addresses
    mapping(address => bool) public supportedTokens;
    /// @notice Tracks valid duel IDs to prevent duplicates
    mapping(string => bool) public isValidDuelId;
    /// @notice Mapping of duel IDs to duel information
    mapping(string => Duel) public duels;
    /// @notice Mapping of duel IDs to crypto duel information
    mapping(string => CryptoDuel) public cryptoDuels;
    /// @notice USDC token contract address used for payments and fees
    address public usdc;
    /// @notice Address of the bot
    address public bot;
    /// @notice Protocol address to receive fees
    address public protocolAddress;

    /// @notice Struct that stores details of each duel
    struct Duel {
        /// @notice Address of the duel creator
        address creator;
        /// @notice Topic of the duel
        string topic;
        /// @notice UNIX timestamp when the duel creates
        uint256 createTime;
        /// @notice UNIX timestamp when the duel starts
        uint256 startTime;
        /// @notice UNIX timestamp when the duel expires
        uint256 expiryTime;
        /// @notice Minimum wager amount in the duel option
        uint256 minWager;
        /// @notice Status of the duel
        DuelStatus duelStatus;
        /// @notice Category of the duel
        DuelCategory category;
    }

    /// @notice Struct that stores details of each crypto duel
    struct CryptoDuel {
        /// @notice Address of the duel creator
        address creator;
        /// @notice UNIX timestamp when the duel creates
        uint256 createTime;
        /// @notice UNIX timestamp when the duel starts
        uint256 startTime;
        /// @notice UNIX timestamp when the duel expires
        uint256 expiryTime;
        /// @notice Minimum wager amount in the duel option
        uint256 minWager;
        /// @notice Trigger value
        uint256 triggerValue;
        /// @notice Trigger type
        TriggerType triggerType;
        /// @notice Trigger condition
        TriggerCondition triggerCondition;
        /// @notice Status of the duel
        DuelStatus duelStatus;
    }

    /// @notice Enum representing different possible duel durations
    enum DuelDuration {
        ThreeHours,
        SixHours,
        TwelveHours
    }

    /// @notice Enum representing the current status of a duel
    enum DuelStatus {
        NotStarted,
        BootStrapped,
        Live,
        Settled,
        Cancelled
    }

    /// @notice Enum representing categories a duel can belong to
    enum DuelCategory {
        Any,
        Crypto,
        Politics,
        Sports,
        Twitter,
        NFTs,
        News
    }

    /// @notice Enum representing trigger type
    enum TriggerType {
        Absolute,
        Percentage
    }

    /// @notice Enum representing trigger condition
    enum TriggerCondition {
        Above,
        Below
    }

    /// @notice Emitted when a new duel is created
    /// @param creator The address of the duel creator
    /// @param duelId The unique ID of the duel
    /// @param topic The description of duel
    /// @param options The options of the duel
    /// @param createTime The time the duel was created
    /// @param expiryTime The time the duel will expire
    /// @param createDuelFee The fee paid for creating the duel
    /// @param category The category of the duel
    event DuelCreated(
        address creator,
        string duelId,
        string topic,
        string[] options,
        uint256 createTime,
        uint256 expiryTime,
        uint256 createDuelFee,
        DuelCategory category
    );

    /// @notice Emitted when a new duel is created
    /// @param creator The address of the duel creator
    /// @param tokens The addresses of tokens
    /// @param duelId The unique ID of the duel
    /// @param options The options of the duel
    /// @param createTime The time the duel was created
    /// @param expiryTime The time the duel will expire
    /// @param createDuelFee The fee paid for creating the duel
    /// @param category The category of the duel
    event CryptoDuelCreated(
        address creator,
        address[] tokens,
        string duelId,
        string[] options,
        uint256 createTime,
        uint256 expiryTime,
        uint256 createDuelFee,
        uint256 triggerValue,
        TriggerType triggerType,
        TriggerCondition triggerCondition,
        DuelCategory category
    );

    /// @notice Emitted when a participant joins a duel
    /// @param duelId The ID of the duel being joined
    /// @param topic The topic related to the token
    /// @param participant The address of the participant
    /// @param amount The amount wagered
    /// @param joinTime The time the participant joined the duel
    event DuelJoined(string duelId, string topic, address participant, uint256 amount, uint256 joinTime);

    /// @notice Emitted when a participant joins a duel
    /// @param duelId The ID of the duel being joined
    /// @param participant The address of the participant
    /// @param token The token being wagered on
    /// @param amount The amount wagered
    /// @param joinTime The time the participant joined the duel
    event CryptoDuelJoined(string duelId, address participant, address token, uint256 amount, uint256 joinTime);

    /// @notice Emitted when a duel starts
    /// @param duelId The ID of the duel that started
    /// @param startTime The time the duel started
    event DuelStarted(string duelId, uint256 startTime);

    /// @notice Emitted when a duel is settled and the winner is determined
    /// @param duelId The ID of the duel that was settled
    /// @param winningTopic The topic associated with the winning token
    /// @param optionIndex The option index
    event DuelSettled(string duelId, string winningTopic, uint256 optionIndex);

    /// @notice Emitted when a user withdraws their earnings
    /// @param user The address of the user withdrawing earnings
    /// @param amount The amount withdrawn
    event WithdrawEarning(address user, uint256 amount);

    /// @notice Emitted when a duel creator withdraws their creator fees
    /// @param user The address of the duel creator
    /// @param creatorFee The fee withdrawn by the creator
    event WithdrawCreatorEarning(address user, uint256 creatorFee);

    /// @notice Emitted when protocol fees are withdrawn
    /// @param user The address of the protocol
    /// @param protocolBalance The amount withdrawn as protocol fees
    event WithdrawProtocolFee(address user, uint256 protocolBalance);

    /// @notice Emitted when a refund is issued for a cancelled duel
    /// @param duelId The ID of the cancelled duel
    /// @param option The option for which refund issued
    /// @param recipient The address receiving the refund
    /// @param amount The amount refunded for option
    event RefundIssued(string duelId, string option, address recipient, uint256 amount);

    /// @notice Emitted when a duel is cancelled
    /// @param duelId The ID of the cancelled duel
    /// @param duelStartTime The duel start time
    /// @param duelCancelTime The duel cancel time
    event DuelCancelled(string duelId, uint256 duelStartTime, uint256 duelCancelTime);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract with the USDC token address and bot address
    /// @dev This function can only be called once as it uses the initializer modifier
    /// @param _usdc The address of the USDC token contract
    /// @param _bot The address of the bot
    function initialize(address _usdc, address _bot) public initializer {
        __Ownable_init(msg.sender);
        __Pausable_init();
        __UUPSUpgradeable_init();
        usdc = _usdc;
        bot = _bot;
        createDuelFee = 10 * 1e6; // 10 USDC
        protocolFeePercentage = 200; // 2%
        creatorFeePercentage = 200; // 2%
        bootstrapPeriod = 30 minutes;
        minThreshold = 50 * 1e6; // 50 USDC
    }

    /**
     * @notice Restricts the function to only the bot address
     * @dev Throws FlashDuels__InvalidBot if the caller is not the bot address
     */
    modifier onlyBot() {
        require(bot == msg.sender, FlashDuels__InvalidBot());
        _;
    }

    // ========================== External Functions ========================== //

    /// @notice Pauses the contract, disabling certain critical functions
    /// @dev Can only be called by the owner to prevent further operations during an emergency
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpauses the contract, enabling previously disabled functions
    /// @dev Can only be called by the owner to resume normal contract operations
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Marks a token as supported in the contract
     * @dev Can only be called by the owner to add tokens that can be used in duels
     * @param _token The address of the token to be supported
     */
    function setSupportedToken(address _token) external onlyOwner {
        supportedTokens[_token] = true;
    }

    /**
     * @notice Sets the fee required to create a duel.
     * @dev This function can only be called by the contract owner.
     * It updates the createDuelFee variable with the new fee value.
     * @param _fee The new fee amount to set for creating a duel.
     */
    function setCreateDuelFee(uint256 _fee) external onlyOwner {
        createDuelFee = _fee;
    }

    /**
     * @notice Sets the address of the bot.
     * @dev This function can only be called by the contract owner.
     * It updates the bot variable with the specified address.
     * @param _bot The address of the bot to set.
     */
    function setBotAddress(address _bot) external onlyOwner {
        bot = _bot;
    }

    /**
     * @notice Sets the address of the protocol.
     * @dev This function can only be called by the contract owner.
     * It updates the protocolAddress variable with the new address.
     * @param _protocolAddress The address of the protocol to set.
     */
    function setProtocolAddress(address _protocolAddress) external onlyOwner {
        protocolAddress = _protocolAddress;
    }

    /**
     * @notice Sets the minimum threshold.
     * @dev This function can only be called by the contract owner.
     * It updates the minThreshold variable with the new threshold value.
     * @param _minThreshold The minimum threshold for the duel to start for each topic.
     */
    function setMinimumWagerThreshold(uint256 _minThreshold) external onlyOwner {
        minThreshold = _minThreshold;
    }

    /**
     * @notice Sets the Chainlink price aggregator for a specific token
     * @dev Can only be called by the owner to set up a price feed for supported tokens
     * @param _token The address of the token for which the aggregator is being set
     * @param _aggregator The address of the Chainlink price feed aggregator for the token
     */
    function setPriceAggregator(address _token, address _aggregator) external onlyOwner {
        require(_token != address(0), "Invalid token address");
        require(_aggregator != address(0), "Invalid aggregator address");

        priceAggregator[_token] = _aggregator;
    }

    /**
     * @notice Creates a new duel with the specified parameters
     * @dev Allows any user to create a duel with a predefined duel duration.
     *      A USDC fee is required for duel creation, and the duel starts after the bootstrap period.
     * @param _category The category of the duel (e.g., Politics, or other categories).
     * @param _topic A string representing the topic or title or description or questions in the duel.
     * @param _options A string representing the first option for the duel.
     * @param _minWager The minimum wager amount required to participate in the duel (in the supported token).
     * @param _duelDuration The duration of the duel, chosen from predefined options (3 hours, 6 hours, or 12 hours).
     * @return _duelId A unique string representing the ID of the created duel.
     */
    function createDuel(
        DuelCategory _category,
        string memory _topic,
        string[] memory _options,
        uint256 _minWager,
        DuelDuration _duelDuration
    ) external nonReentrant whenNotPaused returns (string memory) {
        require(_category != DuelCategory.Crypto, "Should not crypto category duel");

        // Transfer USDC fee for duel creation
        require(IERC20(usdc).transferFrom(msg.sender, address(this), createDuelFee), "USDC transfer failed");
        totalProtocolFeesGenerated = totalProtocolFeesGenerated + createDuelFee;

        // Determine the expiry duration based on the selected enum value
        uint256 duelDuration;
        if (_duelDuration == DuelDuration.ThreeHours) {
            duelDuration = 3 hours;
        } else if (_duelDuration == DuelDuration.SixHours) {
            duelDuration = 6 hours;
        } else if (_duelDuration == DuelDuration.TwelveHours) {
            duelDuration = 12 hours;
        } else {
            revert("Invalid expiry time");
        }

        string memory _duelId = generateDuelId(msg.sender);
        Duel storage duel = duels[_duelId];
        duel.creator = msg.sender;
        duel.topic = _topic;
        duel.createTime = block.timestamp;
        // duel.startTime will be updated in startDuel function
        duel.expiryTime = block.timestamp + bootstrapPeriod + duelDuration;
        duel.minWager = _minWager; // let's say 10 USDC, will be stored in 10 * 1e6
        duel.duelStatus = DuelStatus.BootStrapped;
        duel.category = _category;
        // totalWagerForOption, startPriceToken, duelUsersForOption,  userWager will be updated in joinDuel
        duelIdToOptions[_duelId] = _options;
        creatorToDuelIds[msg.sender].push(_duelId);

        emit DuelCreated(
            msg.sender, _duelId, _topic, _options, block.timestamp, duel.expiryTime, createDuelFee, _category
        );

        return _duelId;
    }
    /**
     * @notice Creates a new crypto duel.
     * @param _tokens Allowed tokens for wagering.
     * @param _options Betting options for the duel.
     * @param _minWager Minimum wager amount.
     * @param _triggerValue Value that triggers the outcome.
     * @param _triggerType Type of trigger (e.g., absolute, percentage).
     * @param _triggerCondition Condition for triggering (e.g., above, below.
     * @param _duelDuration Duration of the duel.
     * @return Duel ID as a string.
     */

    function createCryptoDuel(
        address[] memory _tokens,
        string[] memory _options,
        uint256 _minWager,
        uint256 _triggerValue,
        TriggerType _triggerType,
        TriggerCondition _triggerCondition,
        DuelDuration _duelDuration
    ) external nonReentrant whenNotPaused returns (string memory) {
        for (uint256 i = 0; i < _tokens.length; i++) {
            require(supportedTokens[_tokens[i]], "Unsupported tokens");
        }
        // Transfer USDC fee for duel creation
        require(IERC20(usdc).transferFrom(msg.sender, address(this), createDuelFee), "USDC transfer failed");
        totalProtocolFeesGenerated = totalProtocolFeesGenerated + createDuelFee;

        // Determine the expiry duration based on the selected enum value
        uint256 duelDuration;
        if (_duelDuration == DuelDuration.ThreeHours) {
            duelDuration = 3 hours;
        } else if (_duelDuration == DuelDuration.SixHours) {
            duelDuration = 6 hours;
        } else if (_duelDuration == DuelDuration.TwelveHours) {
            duelDuration = 12 hours;
        } else {
            revert("Invalid expiry time");
        }

        string memory _duelId = generateDuelId(msg.sender);
        CryptoDuel storage duel = cryptoDuels[_duelId];
        duel.creator = msg.sender;
        duel.createTime = block.timestamp;
        // duel.startTime, startPriceToken will be updated in startDuel function
        duel.expiryTime = block.timestamp + bootstrapPeriod + duelDuration;
        duel.minWager = _minWager; // let's say 10 USDC, will be stored in 10 * 1e6
        duel.triggerValue = _triggerValue;
        duel.triggerType = _triggerType;
        duel.triggerCondition = _triggerCondition;
        duel.duelStatus = DuelStatus.BootStrapped;
        // totalWagerForOption, duelUsersForOption,  userWager will be updated in joinDuel
        duelIdToOptions[_duelId] = _options;
        duelIdToTokens[_duelId] = _tokens;
        creatorToDuelIds[msg.sender].push(_duelId);

        emit CryptoDuelCreated(
            msg.sender,
            _tokens,
            _duelId,
            _options,
            block.timestamp,
            duel.expiryTime,
            createDuelFee,
            _triggerValue,
            _triggerType,
            _triggerCondition,
            DuelCategory.Crypto
        );

        return _duelId;
    }

    /// @notice Allows a user to join an existing duel by placing a wager on one of the two sides.
    /// @dev This function checks if the duel exists and is live, ensures that the selected token
    ///      is valid for the duel, and validates the wager amount against the minimum required.
    ///      Users must choose one of the tokens used in the duel and place a wager.
    ///      If the wager is on Topic A, the wager is recorded in `wagersA`; otherwise, it's recorded in `wagersB`.
    /// @param _duelId The ID of the duel to join.
    /// @param _optionsIndex The option index).
    /// @param _amount The amount of the token to wager in the duel.
    function joinDuel(string memory _duelId, uint256 _optionsIndex, uint256 _amount)
        external
        nonReentrant
        whenNotPaused
    {
        Duel storage duel = duels[_duelId];
        require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
        require(duel.category != DuelCategory.Crypto, "Should not a crypto duel");
        require(duel.duelStatus == DuelStatus.BootStrapped || duel.duelStatus == DuelStatus.Live, "Duel isn't live");
        require(block.timestamp < duel.expiryTime, "Duel expired");
        require(_amount >= duel.minWager, "Wager below minimum");
        // Transfer the wager amount in USDC to the contract
        require(IERC20(usdc).transferFrom(msg.sender, address(this), _amount), "Token transfer failed");

        // Increment wager for the selected topic
        totalWagerForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;
        duelUsersForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]].push(msg.sender);
        userWager[msg.sender][_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;

        emit DuelJoined(_duelId, duel.topic, msg.sender, _amount, block.timestamp);
    }

    /// @notice Allows a user to join an existing duel by placing a wager on one of the two sides.
    /// @dev This function checks if the duel exists and is live, ensures that the selected token
    ///      is valid for the duel, and validates the wager amount against the minimum required.
    ///      Users must choose one of the tokens used in the duel and place a wager.
    ///      If the wager is on Topic A, the wager is recorded in `wagersA`; otherwise, it's recorded in `wagersB`.
    /// @param _duelId The ID of the duel to join.
    /// @param _token The address of the token to wager (must be either token A or token B of the duel).
    /// @param _optionsIndex The option index of the duel.
    /// @param _amount The amount of the token to wager in the duel.
    function joinCryptoDuel(string memory _duelId, address _token, uint256 _optionsIndex, uint256 _amount)
        external
        nonReentrant
        whenNotPaused
    {
        CryptoDuel storage duel = cryptoDuels[_duelId];
        require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
        require(duel.duelStatus == DuelStatus.BootStrapped || duel.duelStatus == DuelStatus.Live, "Duel isn't live");
        require(block.timestamp < duel.expiryTime, "Duel expired");
        require(supportedTokens[_token], "Invalid token for this duel");
        require(_amount >= duel.minWager, "Wager below minimum");
        // Transfer the wager amount in USDC to the contract
        require(IERC20(usdc).transferFrom(msg.sender, address(this), _amount), "Token transfer failed");

        // Increment wager for the selected topic
        totalWagerForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;
        duelUsersForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]].push(msg.sender);
        userWager[msg.sender][_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;

        emit CryptoDuelJoined(_duelId, msg.sender, _token, _amount, block.timestamp);
    }

    /**
     * @notice Starts the duel once the bootstrap period has ended and both sides have met the minimum wager requirements.
     * @dev This function performs several checks before starting the duel:
     *      - Verifies that the duel exists.
     *      - Ensures that the bootstrap period has ended.
     *      - Confirms that both sides of the duel have met the minimum wager thresholds.
     *      - Fetches the initial prices for both tokens involved in the duel from an oracle (if it's a crypto duel).
     *      - Marks the duel as live and records the start time.
     *      Only callable by the bot when the contract is not paused, and non-reentrant.
     * @param _duelCategory The duel category.
     * @param _duelId The ID of the duel to be started.
     * Emits a {DuelStarted} event upon successful execution.
     */
    function startDuel(DuelCategory _duelCategory, string memory _duelId) external nonReentrant whenNotPaused onlyBot {
        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
            // Ensure the bootstrap period has ended
            require(block.timestamp >= duel.createTime + bootstrapPeriod, "Bootstrap period not ended");
            // Ensure the duel is not already live
            require(duel.duelStatus == DuelStatus.BootStrapped, "Duel has already started or settled");
            // Ensure both tokens have met the minimum wager requirements
            uint256 optionsLength = duelIdToOptions[_duelId].length;
            for (uint256 i = 0; i < optionsLength; i++) {
                require(
                    totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] >= minThreshold,
                    "Threshold not reached for each options to start the duel"
                );
            }
            // Record the start time and mark the duel as live
            duel.startTime = block.timestamp;
            uint256 duelDuration = duel.expiryTime - (duel.createTime + bootstrapPeriod);
            duel.expiryTime = block.timestamp + duelDuration;
            duel.duelStatus = DuelStatus.Live;
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            uint256 duelTokensLength = duelIdToTokens[_duelId].length;
            for (uint256 i = 0; i < duelTokensLength; i++) {
                startPriceToken[_duelId][duelIdToTokens[_duelId][i]] = getOraclePrice(duelIdToTokens[_duelId][i]);
            }
            // Record the start time and mark the duel as live
            cryptoDuel.startTime = block.timestamp;
            uint256 duelDuration = cryptoDuel.expiryTime - (cryptoDuel.createTime + bootstrapPeriod);
            cryptoDuel.expiryTime = block.timestamp + duelDuration;
            cryptoDuel.duelStatus = DuelStatus.Live;
        }

        emit DuelStarted(_duelId, block.timestamp);
    }

    /**
     * @notice Settles the duel after it has expired, distributing the winnings to the correct side.
     * @dev This function checks if the duel is live and has expired before proceeding.
     *      It calculates the winning side based on price deltas (for Crypto duels) and distributes
     *      the winnings after deducting the protocol and creator fees.
     *      Only callable by the bot.
     * @param _duelCategory The duel category.
     * @param _duelId The ID of the duel to settle.
     * @param _optionIndex The option index of the duel.
     * Emits a {DuelSettled} event with the duel ID and the winning topic.
     */
    function settleDuel(DuelCategory _duelCategory, string memory _duelId, uint256 _optionIndex)
        external
        nonReentrant
        onlyBot
    {
        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            // Ensure the duel is live and not yet settled
            require(duel.duelStatus == DuelStatus.Live, "Duel not live or already settled");
            // Ensure the duel has expired
            require(block.timestamp >= duel.expiryTime, "Duel not expired");
            require(block.timestamp <= duel.expiryTime + (48 * 3600), "Resolving time expired"); // 48 hours to settle duel
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            // Ensure the duel is live and not yet settled
            require(cryptoDuel.duelStatus == DuelStatus.Live, "Duel not live or already settled");
            // Ensure the duel has expired
            require(block.timestamp >= cryptoDuel.expiryTime, "Duel not expired");
            require(block.timestamp <= cryptoDuel.expiryTime + (48 * 3600), "Resolving time expired"); // 48 hours to settle duel
        }
        string[] memory _options = duelIdToOptions[_duelId];
        string memory winningOption = _options[_optionIndex];
        uint256 totalWagerLooser;
        for (uint256 i = 0; i < _options.length; i++) {
            if (i != _optionIndex) {
                totalWagerLooser += totalWagerForOption[_duelId][_options[i]];
            }
        }

        uint256 protocolFee = (totalWagerLooser * protocolFeePercentage) / 10000;
        uint256 creatorFee = (totalWagerLooser * creatorFeePercentage) / 10000;
        uint256 payout = totalWagerLooser - protocolFee - creatorFee;

        totalProtocolFeesGenerated += protocolFee;

        _distributeWinnings(_duelId, winningOption, payout);

        if (_duelCategory != DuelCategory.Crypto) {
            totalCreatorFeeEarned[duels[_duelId].creator] += creatorFee;
            duels[_duelId].duelStatus = DuelStatus.Settled;
        } else {
            totalCreatorFeeEarned[cryptoDuels[_duelId].creator] += creatorFee;
            cryptoDuels[_duelId].duelStatus = DuelStatus.Settled;
        }

        // Emit event indicating that the duel has been settled
        emit DuelSettled(_duelId, winningOption, _optionIndex);
    }

    /// @notice Cancels the duel if the threshold amount is not met after the bootstrap period
    /// @dev This function can only be called by a bot and only after the bootstrap period ends
    /// @param _duelCategory The duel category
    /// @param _duelId The unique ID of the duel to be cancelled
    function cancelDuelIfThresholdNotMet(DuelCategory _duelCategory, string calldata _duelId) external onlyBot {
        // Check if the duel exists
        require(isValidDuelId[_duelId], "Duel doesn't exist");

        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            // Check if the duel has already been cancelled or settled
            require(
                duel.duelStatus != DuelStatus.Cancelled && duel.duelStatus != DuelStatus.Settled,
                "Duel already cancelled or settled"
            );
            // Check if the duel hasn't started (still in bootstrap period)
            require(duel.duelStatus == DuelStatus.BootStrapped, "Duel already started");
            // Check if the bootstrap period has ended
            require(block.timestamp >= duel.createTime + bootstrapPeriod, "Bootstrap period not ended");
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            // Check if the duel has already been cancelled or settled
            require(
                cryptoDuel.duelStatus != DuelStatus.Cancelled && cryptoDuel.duelStatus != DuelStatus.Settled,
                "Duel already cancelled or settled"
            );
            // Check if the duel hasn't started (still in bootstrap period)
            require(cryptoDuel.duelStatus == DuelStatus.BootStrapped, "Duel already started");
            // Check if the bootstrap period has ended
            require(block.timestamp >= cryptoDuel.createTime + bootstrapPeriod, "Bootstrap period not ended");
        }
        // Check if the threshold has been met
        // Ensure both tokens have met the minimum wager requirements
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] < minThreshold, "Threshold met, cannot cancel"
            );
        }
        if (_duelCategory != DuelCategory.Crypto) {
            // Update duel status to Cancelled
            duels[_duelId].duelStatus = DuelStatus.Cancelled;
            emit DuelCancelled(_duelId, duels[_duelId].startTime, block.timestamp);
        } else {
            // Update duel status to Cancelled
            cryptoDuels[_duelId].duelStatus = DuelStatus.Cancelled;
            emit DuelCancelled(_duelId, cryptoDuels[_duelId].startTime, block.timestamp);
        }
    }

    /// @notice Refunds users if the total wagered amount does not meet the minimum threshold after the bootstrap period ends
    /// @dev This function can only be called after the bootstrap period has ended and if the duel hasn't gone live
    /// @param _duelCategory The duel category
    /// @param _duelId The unique ID of the duel for which users are refunded
    function refundDuel(DuelCategory _duelCategory, string calldata _duelId) external nonReentrant {
        // Check if the duel exists and has not yet started
        require(isValidDuelId[_duelId], "Duel doesn't exist");
        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            // Check if the bootstrap period has ended
            require(block.timestamp >= duel.createTime + bootstrapPeriod, "Bootstrap period not ended");
            require(duel.duelStatus == DuelStatus.Cancelled, "Duel is live or settled");
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            // Check if the bootstrap period has ended
            require(block.timestamp >= cryptoDuel.createTime + bootstrapPeriod, "Bootstrap period not ended");
            require(cryptoDuel.duelStatus == DuelStatus.Cancelled, "Duel is live or settled");
        }
        // Check if the total wagers did not meet the minimum threshold
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] < minThreshold, "Threshold met, cannot refund"
            );
            // Refund users who wagered
            uint256 wager = userWager[msg.sender][_duelId][duelIdToOptions[_duelId][i]];
            if (wager > 0) {
                userWager[msg.sender][_duelId][duelIdToOptions[_duelId][i]] = 0;
                IERC20(usdc).transfer(msg.sender, wager);
                emit RefundIssued(_duelId, duelIdToOptions[_duelId][i], msg.sender, wager);
            }
        }
    }

    /**
     * @notice Withdraws earnings for the caller.
     * @param _amount The amount to withdraw.
     */
    function withdrawEarnings(uint256 _amount) external {
        uint256 _allTimeEarnings = allTimeEarnings[msg.sender];
        require(_amount <= _allTimeEarnings, "Amount should be less than equal earnings");
        IERC20(usdc).transfer(msg.sender, _amount);
        emit WithdrawEarning(msg.sender, _amount);
    }

    /**
     * @notice Withdraws creator fees for the caller.
     */
    function withdrawCreatorFee() external {
        uint256 creatorFee = totalCreatorFeeEarned[msg.sender];
        require(creatorFee > 0, "No funds available");
        IERC20(usdc).transfer(msg.sender, creatorFee);
        emit WithdrawCreatorEarning(msg.sender, creatorFee);
    }
    /**
     * @notice Withdraws protocol fees by the owner.
     */

    function withdrawProtocolFees() external onlyOwner {
        uint256 protocolBalance = totalProtocolFeesGenerated;
        require(protocolBalance > 0, "No funds available");
        IERC20(usdc).transfer(msg.sender, protocolBalance);
        emit WithdrawProtocolFee(msg.sender, protocolBalance);
    }

    /**
     * @notice Fallback function that receives Ether.
     */
    fallback() external payable {}

    /**
     * @notice Receive function that receives Ether.
     */
    receive() external payable {}

    // // ========================== View Functions ========================== //

    /**
     * @notice Gets the wager amount deposited by a user in a duel.
     * @param _duelId The ID of the duel.
     * @param _user The address of the user whose wager amount is being queried.
     */
    function getWagerAmountDeposited(string memory _duelId, address _user)
        public
        view
        returns (uint256 _optionsLength, string[] memory _options, uint256[] memory _wagerAmountsForOptions)
    {
        _optionsLength = duelIdToOptions[_duelId].length;
        _options = duelIdToOptions[_duelId];
        _wagerAmountsForOptions = new uint256[](_optionsLength);
        for (uint256 i = 0; i < _optionsLength; i++) {
            _wagerAmountsForOptions[i] = userWager[_user][_duelId][_options[i]];
        }
    }

    /**
     * @notice Gets the price from the oracle for a specific token.
     * @param _token The address of the token.
     * @return int256 The latest price from the oracle, in 8 decimals.
     */
    function getOraclePrice(address _token) public view returns (int256) {
        address aggregator = priceAggregator[_token];
        require(aggregator != address(0), "Price aggregator not set");
        AggregatorV3Interface priceFeed = AggregatorV3Interface(aggregator);
        (, int256 price,,,) = priceFeed.latestRoundData();
        return price;
    }
    /**
     * @notice Retrieves the duel IDs created by a specific address.
     * @param _address The address of the duel creator.
     * @return An array of duel IDs associated with the creator.
     */

    function getCreatorToDuelIds(address _address) public view returns (string[] memory) {
        return creatorToDuelIds[_address];
    }
    /**
     * @notice Retrieves the betting options for a specific duel.
     * @param _duelId The ID of the duel.
     * @return An array of options for the specified duel.
     */

    function getDuelIdToOptions(string memory _duelId) public view returns (string[] memory) {
        return duelIdToOptions[_duelId];
    }
    /**
     * @notice Retrieves the allowed tokens for a specific duel.
     * @param _duelId The ID of the duel.
     * @return An array of token addresses for the specified duel.
     */

    function getDuelIdToTokens(string memory _duelId) public view returns (address[] memory) {
        return duelIdToTokens[_duelId];
    }
    /**
     * @notice Retrieves the users who have chosen a specific option in a duel.
     * @param _duelId The ID of the duel.
     * @param _option The selected option.
     * @return An array of addresses of users who bet on the specified option.
     */

    function getDuelUsersForOption(string memory _duelId, string memory _option)
        public
        view
        returns (address[] memory)
    {
        return duelUsersForOption[_duelId][_option];
    }

    /**
     * @notice Calculates the price delta for tokens in a duel.
     * @param _duelId The duel Id.
     * @param _token The token address.
     * @return _endPrice The end price of token.
     * @return _startPrice The start price of token.
     * @return _delta The price change of token.
     * @return _isEndPriceGreater Returns true if end price greater than stat price.
     */
    function getPriceDelta(string memory _duelId, address _token)
        public
        view
        returns (int256 _endPrice, int256 _startPrice, int256 _delta, bool _isEndPriceGreater)
    {
        (_endPrice, _startPrice, _delta, _isEndPriceGreater) = _getPriceDelta(_duelId, _token);
    }

    // ========================== Internal Functions ========================== //

    /**
     * @notice Generates a unique duel ID based on user and block details
     * @dev Uses the user address, block data, and a nonce to generate a unique ID via keccak256 hashing
     * @param userAddress The address of the user creating the duel
     * @return duelIdStr A string representing the unique duel ID
     */
    function generateDuelId(address userAddress) internal returns (string memory) {
        nonce++; // Increment nonce to ensure uniqueness

        // Generate a new duel ID using keccak256
        bytes32 newId = keccak256(
            abi.encodePacked(block.timestamp, block.prevrandao, userAddress, nonce, blockhash(block.number - 1))
        );

        // Convert the bytes32 ID to a string
        string memory duelIdStr = toHexString(newId);

        // Ensure the generated ID is unique
        require(!isValidDuelId[duelIdStr], "ID collision detected");

        // Mark the ID as used
        isValidDuelId[duelIdStr] = true;

        return duelIdStr;
    }

    /**
     * @notice Converts a bytes32 value to its hexadecimal string representation
     * @dev Used for converting the keccak256 hash to a readable string
     * @param _bytes The bytes32 value to be converted to a string
     * @return A string representing the hexadecimal version of the bytes32 input
     */
    function toHexString(bytes32 _bytes) internal pure returns (string memory) {
        bytes memory hexChars = "0123456789abcdef";
        bytes memory str = new bytes(64); // Each byte takes 2 hex characters (32 bytes = 64 hex characters)

        for (uint256 i = 0; i < 32; i++) {
            str[i * 2] = hexChars[uint8(_bytes[i] >> 4)]; // First nibble (4 bits)
            str[1 + i * 2] = hexChars[uint8(_bytes[i] & 0x0f)]; // Second nibble (4 bits)
        }

        return string(str);
    }

    /**
     * @notice Distributes winnings to the users who bet on the winning side.
     * @dev This function calculates and distributes both the winning token and a portion of the losing token to the winners.
     * It transfers the respective amounts based on each user's wager proportionally.
     * @param _duelId The duel for which the winnings are being distributed.
     * @param _winningOption The winning option.
     * @param _payout The total amount of the winning token to be distributed among the winners.
     */
    function _distributeWinnings(string memory _duelId, string memory _winningOption, uint256 _payout) internal {
        address[] storage winners = duelUsersForOption[_duelId][_winningOption];
        uint256 totalWinningWagers = totalWagerForOption[_duelId][_winningOption];

        for (uint256 i = 0; i < winners.length; i++) {
            address winner = winners[i];
            uint256 winnerWager = userWager[winner][_duelId][_winningOption];

            uint256 winnerShare = (winnerWager * 1e18) / totalWinningWagers;
            uint256 winnerWinningTokenAmount = (winnerShare * _payout) / 1e18;

            allTimeEarnings[winner] += (winnerWager + winnerWinningTokenAmount);
            // Transfer the winning token amount to the winner
            // require(
            //     IERC20(usdc).transfer(winner, (winnerWager + winnerWinningTokenAmount)),
            //     "Winning token transfer failed"
            // );
        }
    }

    /**
     * @notice Gets the price delta of both tokens in a duel using their oracle data.
     * @param _duelId The duel ID.
     * @param _token The token address.
     * @return endPrice The end price of token.
     * @return startPrice The start price of token.
     * @return delta The price change of token.
     * @return isEndPriceGreater Returns true if end price greater than stat price.
     */
    function _getPriceDelta(string memory _duelId, address _token)
        internal
        view
        returns (int256 endPrice, int256 startPrice, int256 delta, bool isEndPriceGreater)
    {
        require(supportedTokens[_token], "Invalid supported tokens");
        endPrice = getOraclePrice(_token);
        startPrice = startPriceToken[_duelId][_token];
        delta = endPrice - startPrice;
        isEndPriceGreater = endPrice > startPrice;
    }

    /// @notice Authorize an upgrade to a new implementation
    /// @param newImplementation The address of the new implementation contract
    /// @dev Can only be called by the owner
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
