// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {OptionToken} from "./OptionToken.sol";
import {Duel, CryptoDuel, DuelCategory, DuelDuration, TriggerType, TriggerCondition, DuelStatus, DuelCreated, CryptoDuelCreated, DuelJoined, CryptoDuelJoined, DuelStarted, DuelSettled, DuelCancelled, RefundIssued, WithdrawEarning, WithdrawCreatorEarning, WithdrawProtocolFee} from "./interfaces/IFlashDuels.sol";

/// @title FlashDuels
/// @notice This contract allows users to create and participate in duels by betting on the options.
contract FlashDuels is UUPSUpgradeable, OwnableUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {
    /// @notice Thrown when the bot address is invalid
    error FlashDuels__InvalidBot();
    /// @notice Total protocol fees generated by the contract

    uint256 public totalProtocolFeesGenerated;
    /// @notice Protocol fee percentage taken from the winnings (default 2%)
    uint256 public protocolFeePercentage;
    /// @notice Fee percentage given to the duel creator (default 2%)
    uint256 public creatorFeePercentage;
    /// @notice Time period for bootstrapping before a duel goes live (30 minutes by default)
    uint256 public bootstrapPeriod;
    /// @notice Fee in USDC required to create a duel
    uint256 public createDuelFee;
    /// @notice The minimum threshold for wagering, set to 50 USDC (or configurable)
    uint256 public minThreshold;
    /// @notice Nonce used to generate unique duel IDs
    uint256 private nonce;
    /// @notice Mapping of user to the duelId to the option to the user wager amount
    mapping(address => mapping(string => mapping(string => uint256))) public userWager;
    /// @notice Mapping of duelId to optionIndex to the option token address
    mapping(string => mapping(uint256 => address)) public optionIndexToOptionToken;
    /// @notice Mapping of duelId to the option to the total wager for option
    mapping(string => mapping(string => uint256)) public totalWagerForOption;
    /// @notice Mapping of duelId to the option to the duel users for option
    mapping(string => mapping(string => address[])) public duelUsersForOption;
    /// @notice Mapping of duelId to the token to the start price
    mapping(string => mapping(string => int256)) public startPriceToken;
    /// @notice Mapping to track total bets on duel
    mapping(string => uint256) public totalBetsOnDuel;
    /// @notice Mapping to track total bets on duel option for a particular duel
    mapping(string => mapping(uint256 => mapping(string => uint256))) public totalBetsOnOption;
    /// @notice Mapping to track total fees earned by duel creators
    mapping(address => uint256) public totalCreatorFeeEarned;
    /// @notice Mapping to store multiple duel IDs for the same creator
    mapping(address => string[]) public creatorToDuelIds;
    /// @notice Mapping of duelId to their options
    mapping(string => string[]) public duelIdToOptions;
    /// @notice Mapping of optionIndex to the option
    mapping(uint256 => string) public optionIndexToOption;
    /// @notice Mapping to track total earnings for participants
    mapping(address => uint256) public allTimeEarnings;
    /// @notice Mapping to track valid duel IDs to prevent duplicates
    mapping(string => bool) public isValidDuelId;
    /// @notice Mapping of duel IDs to duel information
    mapping(string => Duel) public duels;
    /// @notice Mapping of duel IDs to crypto duel information
    mapping(string => CryptoDuel) public cryptoDuels;
    /// @notice USDC token contract address used for payments and fees
    address public usdc;
    /// @notice Address of the bot
    address public bot;
    /// @notice Protocol address to receive fees
    address public protocolAddress;

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract with the USDC token address and bot address
    /// @dev This function can only be called once as it uses the initializer modifier
    /// @param _usdc The address of the USDC token contract
    /// @param _bot The address of the bot
    function initialize(address _usdc, address _bot) public initializer {
        __Ownable_init(msg.sender);
        __Pausable_init();
        __UUPSUpgradeable_init();
        usdc = _usdc;
        bot = _bot;
        createDuelFee = 10 * 1e6; // 10 USDC
        protocolFeePercentage = 200; // 2%
        creatorFeePercentage = 200; // 2%
        bootstrapPeriod = 30 minutes;
        minThreshold = 50 * 1e6; // 50 USDC
    }

    /**
     * @notice Restricts the function to only the bot address
     * @dev Throws FlashDuels__InvalidBot if the caller is not the bot address
     */
    modifier onlyBot() {
        require(bot == msg.sender, FlashDuels__InvalidBot());
        _;
    }

    // ========================== External Functions ========================== //

    /// @notice Pauses the contract, disabling certain critical functions
    /// @dev Can only be called by the owner to prevent further operations during an emergency
    function pause() external onlyOwner {
        _pause();
    }

    /// @notice Unpauses the contract, enabling previously disabled functions
    /// @dev Can only be called by the owner to resume normal contract operations
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice Sets the fee required to create a duel.
     * @dev This function can only be called by the contract owner.
     * It updates the createDuelFee variable with the new fee value.
     * @param _fee The new fee amount to set for creating a duel.
     */
    function setCreateDuelFee(uint256 _fee) external onlyOwner {
        createDuelFee = _fee;
    }

    /**
     * @notice Sets the address of the bot.
     * @dev This function can only be called by the contract owner.
     * It updates the bot variable with the specified address.
     * @param _bot The address of the bot to set.
     */
    function setBotAddress(address _bot) external onlyOwner {
        require(_bot != address(0), "Invalid bot address");
        bot = _bot;
    }

    /**
     * @notice Sets the address of the protocol.
     * @dev This function can only be called by the contract owner.
     * It updates the protocolAddress variable with the new address.
     * @param _protocolAddress The address of the protocol to set.
     */
    function setProtocolAddress(address _protocolAddress) external onlyOwner {
        require(_protocolAddress != address(0), "Invalid protocol address");
        protocolAddress = _protocolAddress;
    }

    /**
     * @notice Sets the minimum threshold.
     * @dev This function can only be called by the contract owner.
     * It updates the minThreshold variable with the new threshold value.
     * @param _minThreshold The minimum threshold for the duel to start for each topic.
     */
    function setMinimumWagerThreshold(uint256 _minThreshold) external onlyOwner {
        minThreshold = _minThreshold;
    }

    /**
     * @notice Updates the bootstrap period.
     * @param _bootstrapPeriod The new bootstrap period.
     */
    function updateBootstrapPeriod(uint256 _bootstrapPeriod) external onlyOwner {
        bootstrapPeriod = _bootstrapPeriod;
    }

    /**
     * @notice Creates a new duel with the specified parameters
     * @dev Allows any user to create a duel with a predefined duel duration.
     *      A USDC fee is required for duel creation, and the duel starts after the bootstrap period.
     * @param _category The category of the duel (e.g., Politics, or other categories).
     * @param _topic A string representing the topic or title or description or questions in the duel.
     * @param _options A string representing the first option for the duel.
     * @param _duelDuration The duration of the duel, chosen from predefined options (3 hours, 6 hours, or 12 hours).
     * @return _duelId A unique string representing the ID of the created duel.
     */
    function createDuel(
        DuelCategory _category,
        string memory _topic,
        string[] memory _options,
        DuelDuration _duelDuration
    ) external nonReentrant whenNotPaused returns (string memory) {
        require(_category != DuelCategory.Crypto, "Should not crypto category duel");
        // Transfer USDC fee for duel creation
        require(IERC20(usdc).transferFrom(msg.sender, address(this), createDuelFee), "USDC transfer failed");
        totalProtocolFeesGenerated = totalProtocolFeesGenerated + createDuelFee;

        require(
            _duelDuration == DuelDuration.ThreeHours ||
                _duelDuration == DuelDuration.SixHours ||
                _duelDuration == DuelDuration.TwelveHours,
            "Invalid duel duration"
        );

        string memory _duelId = generateDuelId(msg.sender);
        Duel storage duel = duels[_duelId];
        duel.creator = msg.sender;
        duel.topic = _topic;
        duel.createTime = block.timestamp;
        duel.duelDuration = _duelDuration;
        duel.duelStatus = DuelStatus.BootStrapped;
        duel.category = _category;
        duelIdToOptions[_duelId] = _options;
        creatorToDuelIds[msg.sender].push(_duelId);

        emit DuelCreated(msg.sender, _duelId, _topic, block.timestamp, createDuelFee, _category);

        return _duelId;
    }
    /**
     * @notice Creates a new crypto duel.
     * @param _tokenSymbol Allowed token symbol for wagering.
     * @param _options Betting options for the duel.
     * @param _triggerValue Value that triggers the outcome.
     * @param _triggerType Type of trigger (e.g., absolute, percentage).
     * @param _triggerCondition Condition for triggering (e.g., above, below).
     * @param _duelDuration Duration of the duel.
     * @return Duel ID as a string.
     */

    function createCryptoDuel(
        string memory _tokenSymbol,
        string[] memory _options,
        int256 _triggerValue,
        TriggerType _triggerType,
        TriggerCondition _triggerCondition,
        DuelDuration _duelDuration
    ) external nonReentrant whenNotPaused returns (string memory) {
        // Transfer USDC fee for duel creation
        require(IERC20(usdc).transferFrom(msg.sender, address(this), createDuelFee), "USDC transfer failed");
        totalProtocolFeesGenerated = totalProtocolFeesGenerated + createDuelFee;

        require(
            _duelDuration == DuelDuration.ThreeHours ||
                _duelDuration == DuelDuration.SixHours ||
                _duelDuration == DuelDuration.TwelveHours,
            "Invalid duel duration"
        );

        string memory _duelId = generateDuelId(msg.sender);
        CryptoDuel storage duel = cryptoDuels[_duelId];
        duel.creator = msg.sender;
        duel.tokenSymbol = _tokenSymbol;
        duel.createTime = block.timestamp;
        duel.duelDuration = _duelDuration;
        duel.triggerValue = _triggerValue;
        duel.triggerType = _triggerType;
        duel.triggerCondition = _triggerCondition;
        duel.duelStatus = DuelStatus.BootStrapped;
        duelIdToOptions[_duelId] = _options;
        creatorToDuelIds[msg.sender].push(_duelId);

        emit CryptoDuelCreated(
            msg.sender,
            _tokenSymbol,
            _duelId,
            block.timestamp,
            createDuelFee,
            _triggerValue,
            _triggerType,
            _triggerCondition,
            DuelCategory.Crypto
        );

        return _duelId;
    }

    /// @notice Allows a user to join an existing duel by placing a wager on one of the options.
    /// @param _duelId The ID of the duel to join.
    /// @param _option The option of the duel.
    /// @param _optionsIndex The option index.
    /// @param _optionPrice The option price.
    /// @param _amount The amount of the token to wager in the duel.
    function joinDuel(
        string memory _duelId,
        string memory _option,
        uint256 _optionsIndex,
        uint256 _optionPrice,
        uint256 _amount
    ) external nonReentrant whenNotPaused {
        Duel storage duel = duels[_duelId];
        require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
        require(duel.category != DuelCategory.Crypto, "Should not a crypto duel");
        require(duel.duelStatus == DuelStatus.BootStrapped || duel.duelStatus == DuelStatus.Live, "Duel isn't live");
        require(_amount >= _optionPrice, "Less than minimum wager");
        // Transfer the wager amount in USDC to the contract
        require(IERC20(usdc).transferFrom(msg.sender, address(this), _amount), "Token transfer failed");

        // Increment wager for the selected topic
        totalWagerForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;
        duelUsersForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]].push(msg.sender);
        userWager[msg.sender][_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;

        uint256 amountTokenToMint = (_amount * 1e18) / _optionPrice;
        // @note - zokyo-audit-fix: 2
        address optionToken = optionIndexToOptionToken[_duelId][_optionsIndex];
        if (optionToken == address(0)) {
            // Deploy a new ERC-20 token contract
            OptionToken newOptionToken = new OptionToken(_option, _option);
            // Mint the specified amount of option tokens to the recipient address
            newOptionToken.mint(msg.sender, amountTokenToMint);
            optionToken = address(newOptionToken);
            optionIndexToOptionToken[_duelId][_optionsIndex] = address(newOptionToken);
        } else {
            OptionToken(optionToken).mint(msg.sender, amountTokenToMint);
        }

        totalBetsOnDuel[_duelId] += amountTokenToMint;
        totalBetsOnOption[_duelId][_optionsIndex][_option] += amountTokenToMint;

        emit DuelJoined(
            _duelId,
            duel.topic,
            _option,
            msg.sender,
            optionToken,
            _optionsIndex,
            _amount,
            amountTokenToMint,
            block.timestamp
        );
    }

    /// @notice Allows a user to join an existing duel by placing a wager on one of the options.
    /// @param _duelId The ID of the duel to join.
    /// @param _option The option of the duel.
    /// @param _tokenSymbol Allowed token symbol for wagering.
    /// @param _optionsIndex The option index of the duel.
    /// @param _optionPrice The option price of the duel.
    /// @param _amount The amount of the token to wager in the duel.
    function joinCryptoDuel(
        string memory _duelId,
        string memory _option,
        string memory _tokenSymbol,
        uint256 _optionsIndex,
        uint256 _optionPrice,
        uint256 _amount
    ) external nonReentrant whenNotPaused {
        CryptoDuel storage duel = cryptoDuels[_duelId];
        require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
        require(duel.duelStatus == DuelStatus.BootStrapped || duel.duelStatus == DuelStatus.Live, "Duel isn't live");
        require(_amount >= _optionPrice, "Less than minimum wager");
        // Transfer the wager amount in USDC to the contract
        require(IERC20(usdc).transferFrom(msg.sender, address(this), _amount), "Token transfer failed");

        // Increment wager for the selected topic
        totalWagerForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;
        duelUsersForOption[_duelId][duelIdToOptions[_duelId][_optionsIndex]].push(msg.sender);
        userWager[msg.sender][_duelId][duelIdToOptions[_duelId][_optionsIndex]] += _amount;
        uint256 amountTokenToMint = (_amount * 1e18) / _optionPrice;
        // @note - zokyo-audit-fix: 2
        address optionToken = optionIndexToOptionToken[_duelId][_optionsIndex];
        if (optionToken == address(0)) {
            // Deploy a new ERC-20 token contract
            OptionToken newOptionToken = new OptionToken(_option, _option);
            // Mint the specified amount of option tokens to the recipient address
            newOptionToken.mint(msg.sender, amountTokenToMint);
            optionToken = address(newOptionToken);
            optionIndexToOptionToken[_duelId][_optionsIndex] = address(newOptionToken);
        } else {
            OptionToken(optionToken).mint(msg.sender, amountTokenToMint);
        }

        totalBetsOnDuel[_duelId] += amountTokenToMint;
        totalBetsOnOption[_duelId][_optionsIndex][_option] += amountTokenToMint;

        emit CryptoDuelJoined(
            _duelId,
            _tokenSymbol,
            _option,
            msg.sender,
            optionToken,
            _optionsIndex,
            _amount,
            amountTokenToMint,
            block.timestamp
        );
    }

    /**
     * @notice Starts the duel once the bootstrap period has ended and both sides have met the minimum threshold requirements.
     * @param _duelId The ID of the duel to be started.
     * Emits a {DuelStarted} event upon successful execution.
     */
    function startDuel(string memory _duelId) external nonReentrant whenNotPaused onlyBot {
        Duel storage duel = duels[_duelId];
        require(isValidDuelId[_duelId] && duel.createTime != 0, "Duel doesn't exist");
        // Ensure the duel is not already live
        require(duel.duelStatus == DuelStatus.BootStrapped, "Duel has already started or settled");
        bool _isThresholdMet = _checkIfThresholdMet(_duelId);
        // Ensure the bootstrap period has ended
        // require(
        //     block.timestamp >= duel.createTime + bootstrapPeriod || _isThresholdMet,
        //     "Bootstrap period not ended or threshold not met"
        // );
        require(_isThresholdMet, "Threshold not met");
        // Ensure both tokens have met the minimum wager requirements
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] >= minThreshold,
                "Threshold not reached for each options to start the duel"
            );
        }
        // Record the start time and mark the duel as live
        duel.startTime = block.timestamp;
        // uint256 duelDuration = duel.expiryTime - (duel.createTime + bootstrapPeriod);
        uint256 duelDuration = duel.duelDuration == DuelDuration.ThreeHours
            ? 3 hours
            : duel.duelDuration == DuelDuration.SixHours
                ? 6 hours
                : 12 hours;
        duel.expiryTime = block.timestamp + duelDuration;
        duel.duelStatus = DuelStatus.Live;

        emit DuelStarted(_duelId, block.timestamp, duel.expiryTime);
    }
    /**
     * @notice Starts the crypto duel with the specified ID.
     * @dev Can only be called by the bot when the contract is not paused. Uses nonReentrant for security.
     * @param _duelId The ID of the duel to start.
     * @param _startTokenPrice The start price of the token.
     */

    function startCryptoDuel(
        string memory _duelId,
        int256 _startTokenPrice
    ) external nonReentrant whenNotPaused onlyBot {
        CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
        require(isValidDuelId[_duelId] && cryptoDuel.createTime != 0, "Duel doesn't exist");
        // Ensure the duel is not already live
        require(cryptoDuel.duelStatus == DuelStatus.BootStrapped, "Duel has already started or settled");
        bool _isThresholdMet = _checkIfThresholdMet(_duelId);
        // Ensure the bootstrap period has ended
        // require(
        //     block.timestamp >= cryptoDuel.createTime + bootstrapPeriod || _isThresholdMet,
        //     "Bootstrap period not ended or threshold not met"
        // );
        require(_isThresholdMet, "Threshold not met");
        // Ensure both tokens have met the minimum wager requirements
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] >= minThreshold,
                "Threshold not reached for each options to start the duel"
            );
        }

        startPriceToken[_duelId][cryptoDuel.tokenSymbol] = _startTokenPrice;
        // Record the start time and mark the duel as live
        cryptoDuel.startTime = block.timestamp;
        // uint256 duelDuration = cryptoDuel.expiryTime - (cryptoDuel.createTime + bootstrapPeriod);
        uint256 duelDuration = cryptoDuel.duelDuration == DuelDuration.ThreeHours
            ? 3 hours
            : cryptoDuel.duelDuration == DuelDuration.SixHours
                ? 6 hours
                : 12 hours;
        cryptoDuel.expiryTime = block.timestamp + duelDuration;
        cryptoDuel.duelStatus = DuelStatus.Live;

        emit DuelStarted(_duelId, block.timestamp, cryptoDuel.expiryTime);
    }

    /**
     * @notice Settles the duel after it has expired, distributing the winnings to the correct side.
     * @param _duelId The ID of the duel to settle.
     * @param _optionIndex The option index of the duel.
     * Emits a {DuelSettled} event with the duel ID and the winning topic.
     */
    function settleDuel(string memory _duelId, uint256 _optionIndex) external nonReentrant onlyBot {
        Duel storage duel = duels[_duelId];
        // Ensure the duel is live and not yet settled
        require(duel.duelStatus == DuelStatus.Live, "Duel not live or already settled");
        // Ensure the duel has expired
        require(block.timestamp >= duel.expiryTime, "Duel not expired");
        require(block.timestamp <= duel.expiryTime + (48 * 3600), "Resolving time expired"); // 48 hours to settle duel

        string[] memory _options = duelIdToOptions[_duelId];
        string memory winningOption = _options[_optionIndex];
        uint256 totalWagerLooser;
        for (uint256 i = 0; i < _options.length; i++) {
            if (i != _optionIndex) {
                totalWagerLooser += totalWagerForOption[_duelId][_options[i]];
            }
        }

        uint256 protocolFee = (totalWagerLooser * protocolFeePercentage) / 10000;
        uint256 creatorFee = (totalWagerLooser * creatorFeePercentage) / 10000;
        uint256 payout = totalWagerLooser - protocolFee - creatorFee;

        totalProtocolFeesGenerated += protocolFee;

        _distributeWinnings(_duelId, _optionIndex, winningOption, payout);

        totalCreatorFeeEarned[duels[_duelId].creator] += creatorFee;
        duels[_duelId].duelStatus = DuelStatus.Settled;

        // Emit event indicating that the duel has been settled
        emit DuelSettled(_duelId, winningOption, _optionIndex, block.timestamp);
    }
    /**
     * @notice Settles the crypto duel with the given ID.
     * @dev Can only be called by the bot. Uses nonReentrant for security.
     * @param _duelId The ID of the duel to settle.
     * @param _endTokenPrice The end token price.
     */

    function settleCryptoDuel(string memory _duelId, int256 _endTokenPrice) external nonReentrant onlyBot {
        string memory winningOption;
        uint256 totalWagerLooser;
        uint256 optionIndex;
        CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
        // Ensure the duel is live and not yet settled
        require(cryptoDuel.duelStatus == DuelStatus.Live, "Duel not live or already settled");
        // Ensure the duel has expired
        require(block.timestamp >= cryptoDuel.expiryTime, "Duel not expired");
        require(block.timestamp <= cryptoDuel.expiryTime + (48 * 3600), "Resolving time expired"); // 48 hours to settle duel

        string[] memory _options = duelIdToOptions[_duelId];

        if (cryptoDuel.triggerType == TriggerType.Absolute) {
            int256 _triggerValue = cryptoDuel.triggerValue;
            if (cryptoDuel.triggerCondition == TriggerCondition.Above) {
                winningOption = _endTokenPrice > _triggerValue ? _options[0] : _options[1];
                optionIndex = 0;
                totalWagerLooser += totalWagerForOption[_duelId][_options[1]];
            } else if (cryptoDuel.triggerCondition == TriggerCondition.Below) {
                winningOption = _endTokenPrice > _triggerValue ? _options[1] : _options[0];
                optionIndex = 1;
                totalWagerLooser += totalWagerForOption[_duelId][_options[0]];
            }
        }

        // @note - currently support only TriggerType.Percentage
        // if (cryptoDuel.triggerType == TriggerType.Percentage) {
        // }

        uint256 protocolFee = (totalWagerLooser * protocolFeePercentage) / 10000;
        uint256 creatorFee = (totalWagerLooser * creatorFeePercentage) / 10000;
        uint256 payout = totalWagerLooser - protocolFee - creatorFee;

        totalProtocolFeesGenerated += protocolFee;

        _distributeWinnings(_duelId, optionIndex, winningOption, payout);

        totalCreatorFeeEarned[cryptoDuels[_duelId].creator] += creatorFee;
        cryptoDuels[_duelId].duelStatus = DuelStatus.Settled;

        emit DuelSettled(_duelId, winningOption, optionIndex, block.timestamp);
    }

    /// @notice Cancels the duel if the threshold amount is not met after the bootstrap period
    /// @dev This function can only be called by a bot and only after the bootstrap period ends
    /// @param _duelCategory The duel category
    /// @param _duelId The unique ID of the duel to be cancelled
    function cancelDuelIfThresholdNotMet(DuelCategory _duelCategory, string calldata _duelId) external onlyBot {
        // Check if the duel exists
        require(isValidDuelId[_duelId], "Duel doesn't exist");

        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            // Check if the duel has already been cancelled or settled
            require(
                duel.duelStatus != DuelStatus.Cancelled && duel.duelStatus != DuelStatus.Settled,
                "Duel already cancelled or settled"
            );
            // Check if the duel hasn't started (still in bootstrap period)
            require(duel.duelStatus == DuelStatus.BootStrapped, "Duel already started");
            // Check if the bootstrap period has ended
            require(block.timestamp >= duel.createTime + bootstrapPeriod, "Bootstrap period not ended");
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            // Check if the duel has already been cancelled or settled
            require(
                cryptoDuel.duelStatus != DuelStatus.Cancelled && cryptoDuel.duelStatus != DuelStatus.Settled,
                "Duel already cancelled or settled"
            );
            // Check if the duel hasn't started (still in bootstrap period)
            require(cryptoDuel.duelStatus == DuelStatus.BootStrapped, "Duel already started");
            // Check if the bootstrap period has ended
            require(block.timestamp >= cryptoDuel.createTime + bootstrapPeriod, "Bootstrap period not ended");
        }
        // Check if the threshold has been met
        // Ensure both tokens have met the minimum wager requirements
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] < minThreshold,
                "Threshold met, cannot cancel"
            );
        }
        if (_duelCategory != DuelCategory.Crypto) {
            // Update duel status to Cancelled
            duels[_duelId].duelStatus = DuelStatus.Cancelled;
            emit DuelCancelled(_duelId, duels[_duelId].startTime, block.timestamp);
        } else {
            // Update duel status to Cancelled
            cryptoDuels[_duelId].duelStatus = DuelStatus.Cancelled;
            emit DuelCancelled(_duelId, cryptoDuels[_duelId].startTime, block.timestamp);
        }
    }

    /// @notice Refunds users if the total wagered amount does not meet the minimum threshold after the bootstrap period ends
    /// @dev This function can only be called after the bootstrap period has ended and if the duel hasn't gone live
    /// @param _duelCategory The duel category
    /// @param _duelId The unique ID of the duel for which users are refunded
    function refundDuel(DuelCategory _duelCategory, string calldata _duelId) external nonReentrant {
        // Check if the duel exists and has not yet started
        require(isValidDuelId[_duelId], "Duel doesn't exist");
        if (_duelCategory != DuelCategory.Crypto) {
            Duel storage duel = duels[_duelId];
            // Check if the bootstrap period has ended
            require(block.timestamp >= duel.createTime + bootstrapPeriod, "Bootstrap period not ended");
            require(duel.duelStatus == DuelStatus.Cancelled, "Duel is live or settled");
        } else {
            CryptoDuel storage cryptoDuel = cryptoDuels[_duelId];
            // Check if the bootstrap period has ended
            require(block.timestamp >= cryptoDuel.createTime + bootstrapPeriod, "Bootstrap period not ended");
            require(cryptoDuel.duelStatus == DuelStatus.Cancelled, "Duel is live or settled");
        }
        // Check if the total wagers did not meet the minimum threshold
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            require(
                totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] < minThreshold,
                "Threshold met, cannot refund"
            );
            // Refund users who wagered
            uint256 wager = userWager[msg.sender][_duelId][duelIdToOptions[_duelId][i]];
            if (wager > 0) {
                userWager[msg.sender][_duelId][duelIdToOptions[_duelId][i]] = 0;
                // @note - zokyo-audit-fix-7
                require(IERC20(usdc).transfer(msg.sender, wager), "Transfer failed");
                emit RefundIssued(_duelId, duelIdToOptions[_duelId][i], msg.sender, wager, block.timestamp);
            }
        }
    }
    /**
     * @notice Withdraws earnings for the caller.
     * @param _amount The amount to withdraw.
     */

    function withdrawEarnings(uint256 _amount) external {
        uint256 _allTimeEarnings = allTimeEarnings[msg.sender];
        require(_amount <= _allTimeEarnings, "Amount should be less than equal earnings");
        // @note - zokyo-audit-fix-7
        require(IERC20(usdc).transfer(msg.sender, _amount), "Transfer failed");
        allTimeEarnings[msg.sender] -= _amount;
        emit WithdrawEarning(msg.sender, _amount, block.timestamp);
    }

    /**
     * @notice Withdraws creator fees for the caller.
     */
    function withdrawCreatorFee() external {
        uint256 creatorFee = totalCreatorFeeEarned[msg.sender];
        require(creatorFee > 0, "No funds available");
        // @note - zokyo-audit-fix-7
        require(IERC20(usdc).transfer(msg.sender, creatorFee), "Transfer failed");
        totalCreatorFeeEarned[msg.sender] = 0;
        emit WithdrawCreatorEarning(msg.sender, creatorFee, block.timestamp);
    }
    /**
     * @notice Withdraws protocol fees by the owner.
     */

    function withdrawProtocolFees() external onlyOwner {
        uint256 protocolBalance = totalProtocolFeesGenerated;
        require(protocolBalance > 0, "No funds available");
        // @note - zokyo-audit-fix-7
        require(IERC20(usdc).transfer(msg.sender, protocolBalance), "Transfer failed");
        totalProtocolFeesGenerated = 0;
        emit WithdrawProtocolFee(msg.sender, protocolBalance, block.timestamp);
    }

    /**
     * @notice Fallback function that receives Ether.
     */
    fallback() external payable {}

    /**
     * @notice Receive function that receives Ether.
     */
    receive() external payable {}

    // // ========================== View Functions ========================== //
    /// @notice Checks whether threshold has been met or not for a duel
    /// @param _duelId The unique ID of the duel to be cancelled
    function checkIfThresholdMet(string memory _duelId) public view returns (bool) {
        return _checkIfThresholdMet(_duelId);
    }

    /**
     * @notice Retrieves the duel IDs created by a specific address.
     * @param _address The address of the duel creator.
     * @return An array of duel IDs associated with the creator.
     */
    function getCreatorToDuelIds(address _address) public view returns (string[] memory) {
        return creatorToDuelIds[_address];
    }
    /**
     * @notice Retrieves the betting options for a specific duel.
     * @param _duelId The ID of the duel.
     * @return An array of options for the specified duel.
     */

    function getDuelIdToOptions(string memory _duelId) public view returns (string[] memory) {
        return duelIdToOptions[_duelId];
    }

    /**
     * @notice Retrieves the betting options for a specific duel.
     * @param _duelId The ID of the duel.
     * @param _optionIndex The index of the option token.
     * @return The option token address
     */
    function getOptionIndexToOptionToken(string memory _duelId, uint256 _optionIndex) public view returns (address) {
        return optionIndexToOptionToken[_duelId][_optionIndex];
    }

    /**
     * @notice Retrieves the users who have chosen a specific option in a duel.
     * @param _duelId The ID of the duel.
     * @param _option The selected option.
     * @return An array of addresses of users who bet on the specified option.
     */
    function getDuelUsersForOption(
        string memory _duelId,
        string memory _option
    ) public view returns (address[] memory) {
        return duelUsersForOption[_duelId][_option];
    }

    /**
     * @notice Retrieves the user's share for a specific option in an external duel.
     * @dev This function allows external contracts or users to query the share of a user for a given option in a duel.
     * @param _duelId The unique ID of the duel.
     * @param _optionIndex The index of the option in the duel for which the share is being queried.
     * @param _user The address of the user whose option share is being queried.
     * @return optionShare The share of the user for the specified option in the duel.
     */
    function getUserDuelOptionShare(
        string memory _duelId,
        uint256 _optionIndex,
        address _user
    ) public view returns (uint256 optionShare) {
        return _getUserDuelOptionShare(_duelId, _optionIndex, _user);
    }

    /**
     * @notice Gets the wager amount deposited by a user in a duel.
     * @param _duelId The ID of the duel.
     * @param _user The address of the user whose wager amount is being queried.
     */
    function getWagerAmountDeposited(
        string memory _duelId,
        address _user
    ) public view returns (uint256 _optionsLength, string[] memory _options, uint256[] memory _wagerAmountsForOptions) {
        _optionsLength = duelIdToOptions[_duelId].length;
        _options = duelIdToOptions[_duelId];
        _wagerAmountsForOptions = new uint256[](_optionsLength);
        for (uint256 i = 0; i < _optionsLength; i++) {
            _wagerAmountsForOptions[i] = userWager[_user][_duelId][_options[i]];
        }
    }
    /**
     * @notice Retrieves the allowed tokens for a specific duel.
     * @param _duelId The ID of the duel.
     * @return A token address for the specified duel.
     */

    function getDuelIdToTokenSymbol(string memory _duelId) public view returns (string memory) {
        CryptoDuel memory cryptoDuel = cryptoDuels[_duelId];
        return cryptoDuel.tokenSymbol;
    }

    function getDuel(string memory _duelId) public view returns (Duel memory) {
        return duels[_duelId];
    }

    /**
     * @notice Calculates the price delta for tokens in a duel.
     * @param _duelId The duel Id.
     * @param _tokenSymbol The token symbol.
     * @param _currentOraclePrice The current oracle price.
     * @return _endPrice The end price of token.
     * @return _startPrice The start price of token.
     * @return _delta The price change of token.
     * @return _isEndPriceGreater Returns true if end price greater than stat price.
     */
    function getPriceDelta(
        string memory _duelId,
        string memory _tokenSymbol,
        int256 _currentOraclePrice
    ) public view returns (int256 _endPrice, int256 _startPrice, int256 _delta, bool _isEndPriceGreater) {
        (_endPrice, _startPrice, _delta, _isEndPriceGreater) = _getPriceDelta(
            _duelId,
            _tokenSymbol,
            _currentOraclePrice
        );
    }

    // ========================== Internal Functions ========================== //

    /**
     * @notice Generates a unique duel ID based on user and block details
     * @dev Uses the user address, block data, and a nonce to generate a unique ID via keccak256 hashing
     * @param userAddress The address of the user creating the duel
     * @return duelIdStr A string representing the unique duel ID
     */
    function generateDuelId(address userAddress) internal returns (string memory) {
        nonce++; // Increment nonce to ensure uniqueness

        // Generate a new duel ID using keccak256
        bytes32 newId = keccak256(
            abi.encodePacked(block.timestamp, block.prevrandao, userAddress, nonce, blockhash(block.number - 1))
        );

        // Convert the bytes32 ID to a string
        string memory duelIdStr = toHexString(newId);

        // Ensure the generated ID is unique
        require(!isValidDuelId[duelIdStr], "ID collision detected");

        // Mark the ID as used
        isValidDuelId[duelIdStr] = true;

        return duelIdStr;
    }

    /**
     * @notice Converts a bytes32 value to its hexadecimal string representation
     * @dev Used for converting the keccak256 hash to a readable string
     * @param _bytes The bytes32 value to be converted to a string
     * @return A string representing the hexadecimal version of the bytes32 input
     */
    function toHexString(bytes32 _bytes) internal pure returns (string memory) {
        bytes memory hexChars = "0123456789abcdef";
        bytes memory str = new bytes(64); // Each byte takes 2 hex characters (32 bytes = 64 hex characters)

        for (uint256 i = 0; i < 32; i++) {
            str[i * 2] = hexChars[uint8(_bytes[i] >> 4)]; // First nibble (4 bits)
            str[1 + i * 2] = hexChars[uint8(_bytes[i] & 0x0f)]; // Second nibble (4 bits)
        }

        return string(str);
    }

    /**
     * @notice Distributes winnings to the users who bet on the winning side.
     * @param _duelId The duel for which the winnings are being distributed.
     * @param _winningOption The winning option.
     * @param _payout The total amount of the winning token to be distributed among the winners.
     */
    function _distributeWinnings(
        string memory _duelId,
        uint256 _optionIndex,
        string memory _winningOption,
        uint256 _payout
    ) internal {
        address[] storage winners = duelUsersForOption[_duelId][_winningOption];
        uint256 totalWinningWagers = totalWagerForOption[_duelId][_winningOption];
        uint256 winningOptionPoolBalance = totalWinningWagers + _payout;

        for (uint256 i = 0; i < winners.length; i++) {
            address winner = winners[i];
            uint256 winnerShare = _getUserDuelOptionShare(_duelId, _optionIndex, winner);
            uint256 winnerWinningTokenAmount = (winnerShare * winningOptionPoolBalance) / 1e18;

            allTimeEarnings[winner] += winnerWinningTokenAmount;
        }
    }
    /**
     * @notice Retrieves the user's share for a specific option in a duel.
     * @dev This function calculates and returns the share of a user in a given option of a duel.
     * @param _duelId The unique ID of the duel.
     * @param _optionIndex The index of the option in the duel for which the share is being calculated.
     * @param _user The address of the user whose share is to be retrieved.
     * @return optionShare The share of the user for the specified option in the duel.
     */

    function _getUserDuelOptionShare(
        string memory _duelId,
        uint256 _optionIndex,
        address _user
    ) internal view returns (uint256 optionShare) {
        address optionToken = optionIndexToOptionToken[_duelId][_optionIndex];
        uint256 optionTokenBalance = IERC20(optionToken).balanceOf(_user);
        uint256 totalOptionTokenSupply = IERC20(optionToken).totalSupply();
        optionShare = (optionTokenBalance * 1e18) / totalOptionTokenSupply;
    }

    /**
     * @notice Gets the price delta of both tokens in a duel using their oracle data.
     * @param _duelId The duel ID.
     * @param _tokenSymbol The token symbol.
     * @param _currentOraclePrice The current oracle price.
     * @return endPrice The end price of token.
     * @return startPrice The start price of token.
     * @return delta The price change of token.
     * @return isEndPriceGreater Returns true if end price greater than stat price.
     */
    function _getPriceDelta(
        string memory _duelId,
        string memory _tokenSymbol,
        int256 _currentOraclePrice
    ) internal view returns (int256 endPrice, int256 startPrice, int256 delta, bool isEndPriceGreater) {
        endPrice = _currentOraclePrice;
        startPrice = startPriceToken[_duelId][_tokenSymbol];
        delta = endPrice - startPrice;
        isEndPriceGreater = endPrice > startPrice;
    }

    /// @notice Checks whether the threshold has been met for a duel.
    /// @param _duelId The unique ID of the duel to be checked.
    /// @return Returns true if the threshold is met for all options in the duel; otherwise, false.
    function _checkIfThresholdMet(string memory _duelId) public view returns (bool) {
        uint256 optionsLength = duelIdToOptions[_duelId].length;
        for (uint256 i = 0; i < optionsLength; i++) {
            if (totalWagerForOption[_duelId][duelIdToOptions[_duelId][i]] < minThreshold) {
                return false; // Returns false if any option is below the threshold
            }
        }
        return true; // Returns true if all options meet or exceed the threshold
    }

    /// @notice Authorize an upgrade to a new implementation
    /// @param newImplementation The address of the new implementation contract
    /// @dev Can only be called by the owner
    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}
}
